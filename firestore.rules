/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and personal vocabulary,
 * and a mixed access model for sessions and vocabulary cards within sessions. User profiles
 * and vocabulary are strictly controlled by the owning user.  Sessions are accessible based
 * on their 'visibility' property, and vocabulary cards within sessions are manageable by
 * the session host and card creator. Data shape validation is relaxed in this prototype phase.
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /users/{userId}/personalVocabulary/{personalVocabularyId}: User's personal vocabulary.
 * - /sessions/{sessionId}: Collaborative learning sessions.
 * - /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}: Vocabulary cards within a session.
 *
 * Key Security Decisions:
 * - User profiles are private and only accessible to the authenticated user.
 * - Personal vocabulary is private and only accessible to the authenticated user.
 * - Sessions can be either public or private, controlled by the `visibility` field.
 * - Vocabulary cards within sessions are manageable by the session host and card creator.
 * - Data shape validation is relaxed during prototyping for rapid iteration.
 *
 * Denormalization for Authorization:
 * - The `Session` document contains `hostId` to quickly authorize session-related operations.
 * - The `VocabularyCard` document contains `creatorId` to quickly authorize card-related operations.
 *
 * Structural Segregation:
 * - Private user data is stored under /users/{userId} to ensure clear ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles, ensuring only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list): Authenticated user with matching userId.
     * @deny (get, create, update, delete, list): Any other user.
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(userId) && resource.data.id == request.resource.data.id;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secure personal vocabulary, ensuring only the authenticated user can manage their own vocabulary.
     * @path /users/{userId}/personalVocabulary/{personalVocabularyId}
     * @allow (get, create, update, delete, list): Authenticated user with matching userId.
     * @deny (get, create, update, delete, list): Any other user.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/personalVocabulary/{personalVocabularyId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(userId) && resource != null && resource.data.userId == request.resource.data.userId;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secure collaborative learning sessions based on the 'visibility' field.
     * @path /sessions/{sessionId}
     * @allow (get, list): Public read access.
     * @allow (create): Only authenticated users can create sessions, and the hostId must match the user ID.
     * @allow (update, delete): Only the session host can update or delete sessions.
     * @deny (create): If the hostId does not match the user ID.
     * @deny (update, delete): If not the session host.
     * @principle Manages access to sessions based on visibility and host ownership.
     */
    match /sessions/{sessionId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isHost(hostId) {
        return request.auth != null && request.auth.uid == hostId;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isHost(resource.data.hostId) && resource != null;
      allow delete: if isHost(resource.data.hostId) && resource != null;
    }

    /**
     * @description Secure vocabulary cards within a session. Only the session host or the card creator can manage the cards.
     * @path /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}
     * @allow (get, list): Public read access.
     * @allow (create): Only authenticated users can create cards, and the creatorId must match the user ID.
     * @allow (update, delete): Only the session host or the card creator can update or delete cards.
     * @deny (create): If the creatorId does not match the user ID.
     * @deny (update, delete): If not the session host or card creator.
     * @principle Manages access to vocabulary cards based on host and creator ownership.
     */
    match /sessions/{sessionId}/vocabularyCards/{vocabularyCardId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isHost(sessionId) {
          return get(/databases/$(database)/documents/sessions/$(sessionId)).data.hostId == request.auth.uid;
      }
      function isCreator(creatorId) {
        return request.auth != null && request.auth.uid == creatorId;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if (isHost(sessionId) || isCreator(resource.data.creatorId)) && resource != null;
      allow delete: if (isHost(sessionId) || isCreator(resource.data.creatorId)) && resource != null;
    }
  }
}