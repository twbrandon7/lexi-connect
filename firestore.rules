/**
 * @fileoverview Firestore Security Rules for Collaborative Vocabulary Learning App
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data and a
 * collaborative model for shared sessions and vocabulary cards. It leverages
 * path-based authorization and denormalized data for efficient and secure access control.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores user profiles, accessible only to the owner.
 * - `/users/{userId}/personalVocabulary/{personalVocabularyId}`: Stores personal vocabulary, accessible only to the owner.
 * - `/users/{userId}/sessions/{sessionId}`: Stores private sessions created by the user.
 * - `/public_sessions/{sessionId}`: Stores public sessions, accessible to all users.  Must have `visibility == 'public'` and `hostId`
 * - `/sessions/{sessionId}/vocabularyCards/{vocabularyCardId}`: Stores vocabulary cards within a session, accessible based on session permissions.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public sessions are stored in a separate collection to allow for public read access.
 * - Ownership and membership are denormalized onto documents to avoid costly `get()` calls.
 * - Schema validation is relaxed to allow for rapid prototyping but critical authorization fields are validated.
 *
 * Denormalization for Authorization:
 * - `public_sessions` documents MUST contain a `hostId` field indicating the creator.
 *
 * Structural Segregation:
 * - Public sessions are stored in `/public_sessions`, while private sessions are stored under the user's document in `/users/{userId}/sessions`. This enables performant and secure list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (create) - If the authenticated user's UID matches the userId.
     * @allow (get, update, delete) - If the authenticated user's UID matches the userId and the document exists.
     * @allow (list) - Denied to prevent user enumeration.
     * @deny  (any) - If the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for writes and path-based ownership.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Prevent user enumeration

      // Allow self-creation
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;

      // Protect updates and deletes
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == userId; //Enforce immutable user id
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Manages a user's personal vocabulary. Only the authenticated user can manage their own vocabulary.
     * @path /users/{userId}/personalVocabulary/{personalVocabularyId}
     * @allow (create) - If the authenticated user's UID matches the userId.
     * @allow (get, update, delete) - If the authenticated user's UID matches the userId and the document exists.
     * @allow (list) - If the authenticated user's UID matches the userId.
     * @deny  (any) - If the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for writes and path-based ownership.
     */
    match /users/{userId}/personalVocabulary/{personalVocabularyId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId); //Enforce immutable user id
      allow delete: if isSignedIn() && isOwner(userId);
    }

     /**
      * @description Manages private sessions created by a specific user. Only the owner can access.
      * @path /users/{userId}/sessions/{sessionId}
      * @allow (create) - If the authenticated user's UID matches the userId.
      * @allow (get, update, delete) - If the authenticated user's UID matches the userId and the document exists.
      * @allow (list) - If the authenticated user's UID matches the userId.
      * @deny (any) - If the authenticated user's UID does not match the userId.
      * @principle Enforces document ownership for writes and path-based ownership.
      */
    match /users/{userId}/sessions/{sessionId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId); //Enforce immutable hostId
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Manages public sessions. Accessible to all users for read, but only the owner can modify.
     * @path /public_sessions/{sessionId}
     * @allow (get, list) - Public read access.
     * @allow (create) - If the session's visibility is set to 'public' and hostId matches the authenticated user's UID.
     * @allow (update, delete) - If the authenticated user's UID matches the session's hostId and the document exists.
     * @deny  (create, update, delete) - If the session's visibility is not set to 'public' or the hostId does not match the authenticated user's UID.
     * @principle Allows public read access with owner-only writes, enforcing data consistency and visibility.
     */
    match /public_sessions/{sessionId} {
      function isOwner(hostId) {
        return request.auth.uid == hostId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true; // Public read

      allow create: if isSignedIn() && request.resource.data.visibility == 'public' && request.resource.data.hostId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.hostId);
      allow delete: if isSignedIn() && isOwner(resource.data.hostId);
    }

    /**
     * @description Manages vocabulary cards within a session.  Allows creator to modify.
     * @path /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}
     * @allow (get, list) - Public read access.
     * @allow (create) - If the authenticated user's UID matches the creatorId.
     * @allow (update, delete) - If the authenticated user's UID matches the creatorId and the document exists.
     * @deny  (create, update, delete) - If the authenticated user's UID does not match the creatorId.
     * @principle Enforces document ownership for writes.
     */
    match /sessions/{sessionId}/vocabularyCards/{vocabularyCardId} {
      function isCreator(creatorId) {
        return request.auth.uid == creatorId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isCreator(resource.data.creatorId);
      allow delete: if isSignedIn() && isCreator(resource.data.creatorId);
    }
  }
}