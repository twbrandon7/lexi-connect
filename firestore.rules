/**
 * @fileoverview Firestore Security Rules for the collaborative learning app.
 *
 * Core Philosophy:
 * This ruleset prioritizes a flexible data model for prototyping while strictly
 * enforcing authorization based on user roles and document ownership. The
 * primary goal is to prevent unauthorized data access and modification. Data
 * validation is intentionally relaxed to allow for rapid schema iteration.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only by the user.
 * - /users/{userId}/personalVocabulary/{personalVocabularyId}: Stores personal vocabulary, accessible only by the user.
 * - /sessions/{sessionId}: Stores session data with public or private visibility.
 * - /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}: Stores vocabulary cards associated with a session.
 *
 * Key Security Decisions:
 * - Users can only access their own data under /users/{userId}.
 * - Sessions can be public or private based on the `visibility` field.
 * - The `hostId` field on the `Session` document is used to determine ownership.
 * - `list` operations are generally allowed for owner-scoped data and public collections but are disallowed where sensitive user data might be exposed.
 * - No validation is performed on data types or required fields beyond what is essential for authorization.
 *
 * Denormalization for Authorization:
 * - The `hostId` field is present on the `/sessions/{sessionId}` document to allow for direct ownership checks without requiring additional `get()` calls.
 *
 * Structural Segregation:
 * - Public and private sessions are stored in the same `/sessions` collection, with the `visibility` field determining access. This simplifies the data model compared to using separate collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user profile.
     * @path /users/{userId}
     * @allow (create, update, get, delete) if the user's auth UID matches the userId in the path.
     * @deny (create, update, get, delete) if the user's auth UID does not match the userId in the path.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Allows a user to manage their personal vocabulary.
       * @path /users/{userId}/personalVocabulary/{personalVocabularyId}
       * @allow (create, update, get, delete, list) if the user's auth UID matches the userId in the path.
       * @deny (create, update, get, delete, list) if the user's auth UID does not match the userId in the path.
       * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
       */
      match /personalVocabulary/{personalVocabularyId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Allows anyone to read public sessions, but only the host to modify them.
     * @path /sessions/{sessionId}
     * @allow (get, list) if true.
     * @allow (create) if the user is authenticated and the hostId field matches their UID.
     * @allow (update, delete) if the user is authenticated and is the host of the session.
     * @deny (create, update, delete) if the user is not the host of the session.
     * @principle Allows public read access with owner-only writes, enforces document ownership for writes.
     */
    match /sessions/{sessionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isHost(hostId) {
        return isSignedIn() && request.auth.uid == hostId;
      }

      function isExistingHost(hostId) {
          return isHost(hostId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isExistingHost(resource.data.hostId);
      allow delete: if isExistingHost(resource.data.hostId);

      /**
       * @description Allows session hosts and authenticated users to create vocabulary cards,
       * and allows only the creator or host to modify/delete them.
       * @path /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}
       * @allow (get, list) if true.
       * @allow (create) if the user is authenticated and the sessionId is valid.
       * @allow (update, delete) if the user is the creator or the host of the session.
       * @deny (create, update, delete) if the user is not authenticated or does not have the right permissions.
       * @principle Enforces document ownership for writes.
       */
      match /vocabularyCards/{vocabularyCardId} {
        function isCreator(creatorId) {
            return request.auth != null && request.auth.uid == creatorId;
        }

        function isExistingCreator(creatorId) {
            return isCreator(creatorId) && resource != null;
        }
          
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if isExistingCreator(resource.data.creatorId) || isExistingHost(get(/databases/$(database)/documents/sessions/$(sessionId)).data.hostId);
        allow delete: if isExistingCreator(resource.data.creatorId) || isExistingHost(get(/databases/$(database)/documents/sessions/$(sessionId)).data.hostId);
      }
    }
  }
}