/**
 * @fileoverview Firestore Security Rules for Collaborative Vocabulary Learning App
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data and a
 * combination of ownership and visibility-based access for collaborative sessions.
 * Public sessions are stored in a separate collection to optimize read access
 * and simplify security rules.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the authenticated user.
 * - /users/{userId}/personalVocabulary/{personalVocabularyId}: User's personal vocabulary, accessible only to the user.
 * - /users/{userId}/sessions/{sessionId}: Private sessions created by a user, accessible only to the user (host).
 * - /public_sessions/{sessionId}: Public sessions, readable by all users, but writable only by the host.  Must have visibility=public.
 * - /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}: Vocabulary cards within a session, creatable by any user, but updatable/deletable only by the creator.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public sessions are readable by all but only writable by the host.
 * - Sessions enforce visibility is public.
 *
 * Denormalization for Authorization:
 * - Sessions have a `hostId` field to quickly verify ownership for write operations.
 * - Public sessions are stored in a separate collection instead of using a visibility flag on a single session collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profiles. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (get, list): Authenticated user with matching userId.
     * @allow (create): Authenticated user creating their profile with matching userId.
     * @allow (update, delete): Authenticated user with matching userId, and the resource exists.
     * @deny  (get, list): Request from a user that does not match the `userId` in the path.
     * @deny  (create): Request from a user where the `userId` in the path does not match `request.auth.uid`.
     * @deny  (update, delete): Request from a user that does not match the `userId` in the path, or the resource does not exist.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's personal vocabulary. Only the authenticated user can access their own vocabulary.
     * @path /users/{userId}/personalVocabulary/{personalVocabularyId}
     * @allow (get, list): Authenticated user with matching userId.
     * @allow (create): Authenticated user creating a vocabulary entry with matching userId.
     * @allow (update, delete): Authenticated user with matching userId, and the resource exists.
     * @deny  (get, list): Request from a user that does not match the `userId` in the path.
     * @deny  (create): Request from a user where the `userId` in the path does not match `request.auth.uid`.
     * @deny  (update, delete): Request from a user that does not match the `userId` in the path, or the resource does not exist.
     * @principle Enforces document ownership for all operations within a user's personal vocabulary.
     */
    match /users/{userId}/personalVocabulary/{personalVocabularyId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures sessions created by a user. Only the authenticated user (host) can access their own sessions.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (get, list): Authenticated user with matching userId.
     * @allow (create): Authenticated user creating a session with matching userId.
     * @allow (update, delete): Authenticated user with matching userId, and the resource exists.
     * @deny  (get, list): Request from a user that does not match the `userId` in the path.
     * @deny  (create): Request from a user where the `userId` in the path does not match `request.auth.uid`.
     * @deny  (update, delete): Request from a user that does not match the `userId` in the path, or the resource does not exist.
     * @principle Enforces document ownership for all session operations.
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.hostId == userId;
      allow update, delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures public sessions. Readable by all, writable only by the host.  Requires `visibility == 'public'`.
     * @path /public_sessions/{sessionId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid && request.resource.data.visibility == 'public';
     * @allow update, delete: if isSignedIn() && resource.data.hostId == request.auth.uid && resource != null;
     * @deny  (create): The visibility is not set to public.
     * @deny  (update, delete): Request is not from the host, or the resource does not exist.
     * @principle Allows public read access, but enforces ownership and public visibility for writes.
     */
    match /public_sessions/{sessionId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid && request.resource.data.visibility == 'public';
      allow update, delete: if isSignedIn() && resource.data.hostId == request.auth.uid && resource != null;
    }

    /**
     * @description Secures vocabulary cards within a session.
     * @path /sessions/{sessionId}/vocabularyCards/{vocabularyCardId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && request.resource.data.sessionId == sessionId && request.resource.data.creatorId == request.auth.uid;
     * @allow update, delete: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
     * @deny (create): Request is missing necessary fields.
     * @deny (update, delete): Request is not from the creator, or the resource does not exist.
     * @principle Allows public read access, enforces creator ownership for updates and deletes, and validates the sessionId on create.
     */
    match /sessions/{sessionId}/vocabularyCards/{vocabularyCardId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sessionId == sessionId && request.resource.data.creatorId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document based on the userId.
     * @param {string} userId - The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the existing document based on the userId, and that the resource exists.
     * @param {string} userId - The user ID to check against.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}